{
    "collab_server" : "",
    "contents" : "#' create a trtsel object\n#' \n#' Creates an object of class \"trtsel\" given a data.frame containing marker,\n#' treatment, and adverse event status information.  The functions \"plot\",\n#' \"evaluate\", and \"calibrate\" can then be used to plot risk and treatment\n#' effect curves, estimate summary measures, and check model calibration. The\n#' function \"compare\" can also be used to compare two treatment selection\n#' markers.\n#' \n#' \n#' @param formula a 'formula' object including outcome ~ markers and marker by treatment interactions for\n#'  the treatment selection model to be evaluated. The outcome can be either binary or a\n#'   'Surv' object for time-to-event outcomes. Binary variable should equal 1 for cases and 0 for controls.\n#' @param treatment.name  Name of the treatment variable in data.frame \"data\". The treatment variable must be coded 1 for\n#' \"treated\" and 0 for \"un-treated.\"\n#' @param data data.frame object used to fit and evaluate the model. \n#' @param fittedrisk.t0 Instead of providing a marker, fitted risks for T=0 and\n#' T=1 may be provided. This should be the column name of the fitted risk for\n#' T=0 that can be found in 'data'. If fitted risks are provided, a model will\n#' not be fit, and all bootstrap confidence intervals will be conditional on\n#' the model fit provided.\n#' \n#' @param fittedrisk.t1 Name of for the fitted risks given treatment = 1.\n#' @param thresh The treatment effect threshold used to define the treatment\n#' rule: Do not treat if the marker-specific treatment effect is less than\n#' \"thresh\". This is a numeric constant with a default value of 0.\n#' @param study.design Character string indicating the study design used to\n#' collect the data. The three options are \"RCT\" (default),\n#' \"nested case-control\", or \"stratified nested case-control\".  A \"RCT\" design is simply a randomized trial comparing T = 0 to T = 1 with\n#' the marker measured at baseline.  A nested case-control or stratified nested\n#' case-control study samples cases and controls for marker measurement,\n#' perhaps stratified on treatment assignment, from a randomized trial\n#' comparing T = 0 to T = 1.  See Janes et al. (2013) for a full description of\n#' these designs.\n#' \n#' If a \"nested case-control\" or \"stratified nested case-control\" design is\n#' specified, \"cohort.attributes\"\" must be provided (see below).\n#' @param cohort.attributes If a \"nested case-control\" or \"stratified nested\n#' case-control\" design is specified, \"cohort.attributes\" must be provided.\n#' Order does matter.\n#' \n#' For the \"nested case-control\" design, specify the following attributes of\n#' the randomized trial \"cohort\" from which the case-control sample was\n#' selected: \\cr \\cr cohort.attributes = c(cohort sample size, \\cr proportion\n#' treated in cohort (Pr(trt==1)), \\cr adverse event prevalance in cohort\n#' (Pr(event==1)), \\cr fraction of cases sampled from cohort) \\cr \\cr\n#' \n#' For the \"stratitified nested case-control\" design, specify the following\n#' attributes of the randomized trial \"cohort\" from which the stratified\n#' case-control sample was selected: \\cr \\cr cohort.attributes = c(cohort\n#' sample size, \\cr Pr(trt==0 & event==0) in cohort, \\cr Pr(trt==0 & event==1)\n#' in cohort, \\cr Pr(trt==1 & event==0) in cohort, \\cr fraction of cases with\n#' trt == 0 sampled from cohort, \\cr fraction of cases with trt == 1 sampled\n#' from cohort )\\cr \\cr\n#' @param link Link function used to fit the risk model for binary outcomes. Options are\n#' \"logit\"(default), \"probit\", \"cauchit\", \"log\" and \"cloglog.\" Link functions\n#' other than \"logit\" are available only when study.design = \"randomized\n#' cohort\".\n#' \n#' @param default.trt The default treatment assignment to compare with\n#' marker-based treatment. Can either be set at \"trt all\" (default) or \"trt\n#' none\". Use \"trt all\" if everyone is treated and the aim is to discover those\n#' who would benefit from no treatment, but use \"trt none\" if the common\n#' practice is to treat no-one and the goal is to discover those who would\n#' benefit from treatment.\n#' @param prediction.time a landmark prediction time used only when the outcome is a time-to-event Surv object \n#' \n#' @return\n#' \n#' An object of class \"trtsel,\" which is a list containing:\n#' \n#' \\item{model.fit }{ A list containing \"coefficients\" -- a 4 x 4 matrix with\n#' columns for coefficient estimates, standard errors, t-statistics, and\n#' two-sided p-values.  \"cohort.attributes\" -- the vector of cohort.attributes\n#' provided \"study.design\" -- character string of study.design provided }\n#' \\item{derived.data }{ A data.frame with event, trt, and marker information along with\n#' \"fittedrisk.t0\" (risk estimates given no treatment), \"fittedrisk.t1\" (risk\n#' estimates given treatment), \"trt.effect\" (treatment effect estimates), and\n#' \"trt.rec\" (indicator of trt recommendation) columns.  }\n#' \\item{functions}{ For internal package use only }\n#' @seealso \\code{\\link{plot.trtsel}} for plotting risk curves and more,\n#' \\code{\\link{evaluate.trtsel}} for evaluating marker performance,\n#' \\code{\\link{calibrate.trtsel}} for assessing model calibration, and\n#' \\code{\\link{compare.trtsel}} to compare two trtsel object.\n#' @references Janes, Holly; Brown, Marshall D; Pepe, Margaret; Huang, Ying;\n#' \"An Approach to Evaluating and Comparing Biomarkers for Patient Treatment\n#' Selection\" The International Journal of Biostatistics. Volume 0, Issue 0,\n#' ISSN (Online) 1557-4679, ISSN (Print) 2194-573X, DOI: 10.1515/ijb-2012-0052,\n#' April 2014\n#' @examples\n#' \n#' \n#' data(tsdata)\n#' \n#' ###########################\n#' ## Create trtsel objects \n#' ###########################\n#' \n#' trtsel.Y1 <- trtsel(event ~ Y1*trt, \n#'                    treatment.name = \"trt\", \n#'                    data = tsdata, \n#'                    study.design = \"RCT\",\n#'                    link = \"logit\", \n#'                    default.trt = \"trt all\")\n#'\n#' trtsel.Y1\n#' \n#' trtsel.Y2 <- trtsel(event ~ Y2*trt, \n#'                    treatment.name = \"trt\", \n#'                    data = tsdata, \n#'                    default.trt = \"trt all\")\n#' trtsel.Y2\n#' \n#' \n#' # calculate fitted risks using a logistic model \n#' #(one can use any model here, the point is that the fitted risks are provided )\n#' mymod <- glm(event~trt*Y2, data= tsdata, family = binomial(\"logit\"))\n#' \n#' tsdata$fitted.t0 <- predict(mymod, newdata=data.frame(trt = 0, Y2 = tsdata$Y2), type = \"response\")\n#' tsdata$fitted.t1 <- predict(mymod, newdata=data.frame(trt = 1, Y2 = tsdata$Y2), type = \"response\")\n#' \n#' #all bootstrapping done using this object will be conditional on the model fit. \n#' \n#' myfitted.trtsel <- trtsel( event~trt, treatment.name = \"trt\", \n#'                            data = tsdata,\n#'                            fittedrisk.t0 = \"fitted.t0\",\n#'                            fittedrisk.t1 = \"fitted.t1\",\n#'                            default.trt = \"trt all\")\n#' \n#' \n#' \n#' @import survival \n#' @export trtsel\ntrtsel <-\nfunction(formula, treatment.name, data, \n         fittedrisk.t0 = NULL, fittedrisk.t1 = NULL, thresh=0, \n         prediction.time = NULL, \n         study.design = c(\"RCT\", \"nested case-control\", \"stratified nested case-control\"), \n         cohort.attributes = NULL, \n         link = c(\"logit\", \"probit\", \"cauchit\", \"log\", \"cloglog\"), \n         default.trt = c(\"trt all\", \"trt none\") ){\n  \n  call <- match.call() \n  marker.bounds = NULL #depricated, we don't allow for bounded markers now \n  #check data frame \n  if(!is.data.frame(data)){stop('data must be a data.frame')}\n  \n  #checkc to see if all variables are present in data\n  tmpnames <- c(treatment.name, fittedrisk.t0, fittedrisk.t1, all.vars(formula))\n  if(!all(is.element(tmpnames, names(data)))) stop(paste(\"'\", tmpnames[which(!is.element(tmpnames, names(data)))], \"' cannot be found in data.frame provided\", sep = \"\"))\n  \n  #only keep complete cases \n  mycomplete <- complete.cases(data[,tmpnames]); \n  \n  #check for missing data and throw it out, print a warning\n  if(nrow(data)!=sum(mycomplete)){\n    warning(paste(nrow(data)-sum(mycomplete), \"observation(s) were removed due to missing data \\n New sample size is now:\", sum(mycomplete)))\n    data <- data[mycomplete,]\n    \n  }\n  ## Error Checking\n  \n  event.name <- as.character(formula[[2]])\n  #define outcome \n  if(event.name[[1]] == \"Surv\"){\n    outcome = \"time-to-event\" \n    link = \"time-to-event\"\n    if(is.null(prediction.time)) stop(\"'prediction.time' must be set for a time-to-event outcome.\")\n    #make sure prediction time is reasonable value? \n    #...\n  }else{\n    outcome = \"binary\"\n    if(!is.numeric(data[[event.name]]) | !all(is.element(unique(data[[event.name]]), c(0,1)))) stop( \"Binary outcome must be a numeric vector with elements 1 or 0\")\n    link = match.arg(link)\n    if(!is.element(link, c(\"logit\", \"probit\", \"cauchit\", \"log\", \"cloglog\"))) stop(\"link must be one of ''logit'', ''probit'', ''cauchit'', ''log'', ''cloglog''\")\n  }\n  #check event\n  \n\n\n  trt <- data[[treatment.name]]\n  if(!is.numeric(trt) | !all(is.element(unique(trt), c(0,1)))) stop( \"trt must be a numeric vector with elements 1 or 0\") \n  \n  ## if there is only one marker in the model, we keep it around, otherwise set marker to null \n  if(!is.element(treatment.name, all.vars(formula))) stop(\"variable with name treatment.name was not found in the model formula.\")\n  marker.names = all.vars(formula)[!is.element( all.vars(formula), c(event.name, treatment.name)) ]\n  \n  if(any(is.element(marker.names, c(\"fittedrisk.t0\", \"fittedrisk.t1\", \"trt.effect\", \"rec.trt\", \"rec.notrt\")))) stop(\"one of your variable names is in the following set \\n of protected names  {'fittedrisk.t0', 'fittedrisk.t1', 'trt.effect', \\n  'rec.trt', 'rec.notrt',}\\n  please change the names of your variables\")\n  if(length(marker.names)==1){ \n    marker = data[,marker.names]\n    if(!is.numeric(marker)) stop(\"For a model with a single marker, the marker must be numeric.\")\n    \n  }else{\n    marker = NULL\n  }\n  \n  #if(!is.numeric(data[[marker.name]])) stop( \"marker must be a numeric\") \n  #if(length(marker) >1){ stop(\"only a single marker is allowed\")}\n  default.trt <- match.arg(default.trt)\n  if(!is.element(default.trt, c(\"trt all\", \"trt none\"))){ stop( \"default.trt must be either 'trt all' or 'trt none'\")}\n  ## End Error Checking\n\n  d <- thresh\n  study.design = match.arg(study.design) \n  if(study.design == \"RCT\") study.design <- \"randomized cohort\"\n#find out which bootstrapping functions to use based on type\n  if( substr(study.design,1,4)  == \"rand\" ) { \n   \n    boot.sample <- boot.sample.cohort \n\n    if(outcome == \"binary\"){\n      get.summary.measures <- get.summary.measures.cohort\n      get.F <- get.F.cohort\n      }\n    \n    if(outcome == \"time-to-event\"){\n      get.summary.measures <- get.summary.measures.cohort.survival\n      get.F <- get.F.cohort.survival\n    }\n\n    if(length(cohort.attributes) >0) warning(\"study.design = ''randomized cohort'', but cohort.attributes assigned: cohort.attributes will be ignored\"); cohort.attributes=NULL;\n     #just passing null value here \n    \n\n  }else if( substr(study.design, 1, 4) ==\"nest\") { \n    if(outcome == \"time-to-event\") stop(\"study.design must be ''randomized cohort'' for time-to-event outcomes.\")\n    if(link!=\"logit\") warning(\"when study.design is ''nested case-control'' only link=''logit'' is allowed, setting link = ''logit''\"); link = \"logit\"\n    boot.sample <- boot.sample.case.control \n    get.F <- get.F.case.control\n    get.summary.measures <- get.summary.measures.case.control\n\n    if(length(cohort.attributes) != 4){ \n    \n    stop(\"cohort.attributes not specified correctly, when study.design=''nested case-control'': \\n  \n          cohort.attributes = c(cohort sample size, \n          proportion treated in cohort (Pr(trt==1)),\n          adverse event prevalance in cohort (Pr(event==1)),\n          fraction of cases sampled from cohort)\\n\")\n    }\n\n    if(length(trt) > cohort.attributes[1]) stop(\"Sub-cohort sample size larger than input cohort sample size, please check cohort.attributes[1]\")\n\n    if( any(cohort.attributes[-1]<0 ) | any(cohort.attributes[-1] > 1)) stop(\"Probabilities in cohort.attributes are not in (0,1), please check cohort.attributes\")\n\n   # if(length(cohort.attributes) == 3) cohort.attributes <- c(cohort.attributes, 1) # adding f = 1 by default\n    #cohort attributes is c(N, Pr(trt = 1), Pr(event = 1) ) \n\n  }\n  else if( substr(study.design, 1, 5) ==\"strat\") { \n    if(outcome == \"time-to-event\") stop(\"study.design must be ''randomized cohort'' for time-to-event outcomes.\")\n    if(link!=\"logit\") warning(\"when study.design is ''stratified nested case-control'' only link=''logit'' is allowed, setting link = ''logit''\"); link = \"logit\"\n    boot.sample <- boot.sample.stratified.case.control\n    get.F <- get.F.stratified.case.control  \n    get.summary.measures <- get.summary.measures.stratified.case.control\n   # if(length(cohort.attributes) == 5) cohort.attributes <- c(cohort.attributes, 1, 1)\n   if(length(cohort.attributes) != 6){ \n    \n    stop(\"cohort.attributes not specified correctly, when study.design=''nested case-control'': \\n  \n          cohort.attributes = c(cohort sample size, \n                              Pr(trt==0 & event==0) in cohort, \n                              Pr(trt==0 & event==1) in cohort, \n                              Pr(trt==1 & event==0) in cohort, \n                              fraction of cases with trt == 0 sampled from cohort, \n                              fraction of cases with trt == 1 sampled from cohort )\\n \")\n    }\n    \n    ca <- cohort.attributes\n    cohort.attributes = c(ca[1], ca[2], ca[3], ca[4], 1-(ca[2]+ca[3]+ca[4]), ca[5], ca[6])\n\n\n    if(length(trt) > ca[1]) stop(\"Sub-cohort sample size larger than input cohort sample size, please check cohort.attributes[1]\")\n    if( any(cohort.attributes[-1]<0) | any(cohort.attributes[-1] > 1)) stop(\"Probabilities in cohort.attributes are not in (0,1), please check cohort.attributes. \\n Is Pr(trt==0 & event==0) + Pr(trt==0 & event==1) + Pr(trt==1 & event==0) > 1?\")\n\n  }\n  else { stop(\"study.design not specified correctly, must be one of ''RCT'', ''nested case-control'', or ''stratified nested case-control''\") }\n\n  \n  functions <- list(\"boot.sample\" = boot.sample, \"get.F\" = get.F, \"get.summary.measures\" = get.summary.measures)\n\n  rho = cohort.attributes\n\n\n\n  if(!is.null(fittedrisk.t0)) {\n    fitted_risk_t0 = data[[fittedrisk.t0]]\n    if(length(marker.names)>1) warning(\"fitted risks provided: marker data will be ignored\")\n   \n    link <- \"risks_provided\"\n    if(is.null(fittedrisk.t1)) stop(\"must provide fitted risk for trt = 1 as well\")\n    if(any(fitted_risk_t0 > 1) | any(fitted_risk_t0 <0)) stop(\"fitted risks for trt = 0 are outside of bounds (0,1)\")\n    \n  }\n  \n  if(!is.null(fittedrisk.t1)){\n    \n   fitted_risk_t1 = data[[fittedrisk.t1]]\n   if(is.null(fitted_risk_t0)) stop(\"must provide fitted risk for trt = 0 as well\")\n   if(any(fitted_risk_t1 > 1) | any(fitted_risk_t1 <0)) stop(\"fitted risks for trt = 1 are outside of bounds (0,1)\")\n   \n  }  \n\n  # model.fit\n  #returns null if risks are provided\n\n\n\n\n  \n  # derived.data\n\n  #now that we allow for different link functions for \"randomized cohorts\", we need to get the fitted risks using the coefs we calculated\n\n  if(link == \"risks_provided\"){\n    linkinvfun <- NULL\n  }else if(link == \"time-to-event\"){\n   \n    coxfit <- do.call(coxph, list(formula,data))\n    \n    fitted_risk_t0 <- get.risk.t_coxph(coxfit, treatment.name, data, prediction.time, t = 0)\n    fitted_risk_t1 <- get.risk.t_coxph(coxfit, treatment.name, data, prediction.time, t = 1)\n    #we still need to incorporate the nelson aalen baseline haz to get absolute risk at t = 'prediction.time'\n    coef <- summary(coxfit)$coefficients\n    }else{\n      #binary outcome\n      coef <- get.coef( formula = formula, \n                        treatment.name = treatment.name,\n                        data = data,\n                        study.design = study.design, \n                        rho = rho, \n                        link = link)\n      \n    linkinvfun <- binomial(link = link)$linkinv\n    fitted_risk_t0 <- get.risk.t(coef[,1], formula, treatment.name, data, linkinvfun, t = 0)\n    fitted_risk_t1 <- get.risk.t(coef[,1], formula, treatment.name, data, linkinvfun, t = 1)\n    }\n  \n  if(isTRUE(all.equal(fitted_risk_t0, fitted_risk_t1))) warning(\"fitted risks are the same under each treatment arm so treatment effects are all zero, \\n did you forget to include interactions in your risk model?\")\n  \n  model.fit <- list( \"coefficients\" = coef, \"cohort.attributes\" = rho, \n                     \"study.design\" = study.design, \n                     \"link\" = link, \"outcome\" = outcome, \n                     \"thresh\" = d, \n                     \"marker.names\"  = marker.names)\n  \n  \n  \n  trt.effect <- fitted_risk_t0 - fitted_risk_t1\n  if(length(unique(marker))==2){ \n    #find which value of the marker is marker negative\n\n    Meantrteff.y1 <- mean(trt.effect[marker == unique(marker)[1]])\n    Meantrteff.y2 <- mean(trt.effect[marker == unique(marker)[2]])\n  \n   # if(Meantrteff.y1 < d & Meantrteff.y2 <d){ stop()}\n    if(Meantrteff.y1 > Meantrteff.y2){ \n      rec.no.trt <- as.numeric(marker==unique(marker)[2])\n      model.fit$disc.rec.no.trt = unique(marker)[2]\n      }else{\n      rec.no.trt <- as.numeric(marker==unique(marker)[1])\n      model.fit$disc.rec.no.trt = unique(marker)[1]\n    }\n  }else{\n    rec.no.trt <- ifelse( trt.effect < d, 1, 0) # indicator of being marker negative\n  }\n\n  ## if we dont use marker; we use fitted risks\n  derived.data <- data.frame( data[,c(all.vars(formula))] , \n              fittedrisk.t0 = fitted_risk_t0, \n              fittedrisk.t1 = fitted_risk_t1,\n              trt.effect = trt.effect)\n  \n\n  if(default.trt ==\"trt all\"){\n      derived.data$rec.no.trt <- rec.no.trt\n      \n    }else{\n      rec.trt <- 1-rec.no.trt # indicator of being marker negative\n      derived.data$rec.trt <- rec.trt \n    }\n    \n  #need to add sampling weights to time-to-event outcome \n  if(outcome == \"time-to-event\"){\n  \n    tmp <- with(data, eval(formula[[2]]))\n    wi = get.censoring.weights(ti = prediction.time, stime = tmp[,1], status = tmp[,2] )\n    derived.data$censoring.weights  <- wi\n  }\n   \n  out <- list(derived.data=derived.data, \n              formula = formula, \n              treatment.name = treatment.name, \n              prediction.time = prediction.time, \n              model.fit = model.fit, \n              functions  = functions,\n              default.trt = default.trt, \n              call = call)\n  class(out) = \"trtsel\"\n  \n  out\n\n}\n\n",
    "created" : 1474861340242.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "831621654",
    "id" : "BA351566",
    "lastKnownWriteTime" : 1474861242,
    "last_content_update" : 1474861242,
    "path" : "~/TreatmentSelection/R/trtsel.R",
    "project_path" : "R/trtsel.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}